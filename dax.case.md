# 常用DAX及案例

## 过滤功能

### 表格或者列去重  

DAX不存在去重返回去重后的值这样的操作,只能去重后返回表或者列  

#### VALUES

对列或者表进行去重,返回的是一张表  

?> 公式无法直接返回`值`或者`列`, 通常它被用来作为中间处理过程,嵌套在其他公式内。  

##### Syntax

```DAX
VALUES(<TableNameOrColumnName>)
```  

!> 输入TableName或者ColumName,不支持输入表达式  

##### Return value  

当输入是列是,会把列中的值去重后形成单列的表返回,`空值是有效的结果会被保留`  
当输入是表是,会对行进行去重,重复的行会被去除,形成没有重复行的表,`空行是有效的结果会被保留`  

##### Remarks  

这个公式会受到过滤器的影响,也就是上下文语义会影响它的列或者表的范围,比如你有一列是选择区域的,而你在报告中配置了区域的过滤器,这时候如果你选择了区域如杭州,那么当你在公式中输入这张表的时候,实际已经先过滤了区域只有杭州的表结果。  

#### DISTINCT  

对列或者表进行去重,返回的是一张表  

?> 公式无法直接返回`值`或者`列`, 通常它被用来作为中间处理过程,嵌套在其他公式内  

##### 语法

```DAX
DISTINCT(<TableOrColumn>)
```  

!> 输入Table或者Column,意味着输入是支持表达式的,你的表达式能返回表或者列就可以

##### 返回值

当输入是列是,会把列中的值去重后形成单列的表返回,`空值会被过滤`  
当输入是表是,会对行进行去重,重复的行会被去除,形成没有重复行的表,`空行会被过滤`  

##### Remarks  

这个公式会受到过滤器的影响,也就是上下文语义会影响它的列或者表的范围,比如你有一列是选择区域的,而你在报告中配置了区域的过滤器,这时候如果你选择了区域如杭州,那么当你在公式中输入这张表的时候,实际已经先过滤了区域只有杭州的表结果。  

### 为表达式添加过滤条件  

#### CALCULATE  

这是个非常普遍,重要,常用的公式。很多公式本身只能对当前以后的上下文过滤条件进行计算，这个时候如果想为这个公式加上特定的过滤条件，就需要这个公式。  
比如说SUM可以对当前列进行求和，但是如果得到进一步过滤后的列的情况再进行求和，就需要嵌套CALCULATE来先进行过滤，然后对过滤后的剩下的值进行求和。  

##### 语法

```DAX
CALCULATE(<expression>,<filter1>,<filter2>…)  
```  

##### 参数解析  

* expression  
最终要计算的表达式。  

* filter1, filter2,…  
一系列的过滤条件，可以是布尔值，也可以是通过表达式对一张表进行过滤，用逗号隔开  

?> 所有筛选条件的交集形成最终的筛选条件  

##### 返回值  

返回表达式的结果  

##### 案例解析  

产品表:  

| 分类 | 名称 |
| ------ | ------ |
| 手机   | 小米手机 |
| 手机   | 华为手机 |
| 电脑   | 电脑   |
| 显示器 | 显示器 |
| 游戏机 | 游戏机 |

想计算每种分类的数量,创建度量值  

```DAX
数量=COUNTROWS('产品表')  
```

我们把分类和数量放入矩阵, 得到  

| 名称   | 数量 |
| ------ | ------ |
| 小米手机   |  1 |
| 华为手机   |  1 |
| 电脑   |  1 |
| 显示器 |  1 |
| 游戏机 |  1 |  

如果使用CALCULATE, 新建度量值  

```DAX
数量2=CALCULATE(COUNTROWS('产品表'))  
```

不添加任何过滤条件的情况下,结果跟COUNTROWS('产品表')是一致的  

| 名称   | 数量 | 数量1 |
| ------ | ------ |  ------ |
| 小米手机   |  1 |  1 |
| 华为手机   |  1 |  1 |
| 电脑   |  1 |   1 |
| 显示器 |  1 |   1 |
| 游戏机 |  1 |   1 |  

如果只计算手机的数量  

```DAX
数量3 = CALCULATE(COUNTROWS('产品表'), '产品表'[分类]="手机")
```

| 名称   | 数量 | 数量2 | 数量3
| ------ | ------ |  ------ |  ------ |
| 小米手机   |  1 |  1 |  1 |
| 华为手机   |  1 |  1 |  1 |
| 电脑   |  1 |   1 |   |
| 显示器 |  1 |   1 |   |
| 游戏机 |  1 |   1 |   |

可以看到电脑,显示器,游戏机数量都为空,这是因为过滤条件只过滤手机,其他分类基于过滤条件得到了空  

如果想清空过滤条件,算所有分类的综合  

```DAX
数量4 = CALCULATE(COUNTROWS('产品表'), ALL('产品表'[名称]))  
```

| 名称   | 数量 | 数量2 | 数量3 | 数量4 |
| ------ | ------ |  ------ |  ------ |  ------ |
| 小米手机   |  1 |  1 |  1 |  5 |
| 华为手机   |  1 |  1 |  1 |  5 |
| 电脑   |  1 |   1 |   |  5 |
| 显示器 |  1 |   1 |   |  5 |
| 游戏机 |  1 |   1 |   |  5 |

由于它可以是多条件是,所以你可以首先用ALL来清空上下文过滤,再用第二个条件来设定想要的过滤  

```DAX
数量4 = CALCULATE(COUNTROWS('产品表'), ALL('产品表'[名称]), '产品表'[分类]="手机")  
```

| 名称   | 数量 | 数量2 | 数量3 | 数量4|  数量5 |
| ------ | ------ |  ------ |  ------ |  ------ |  ------ |
| 小米手机   |  1 |  1 |  1 |  5 |  2 |
| 华为手机   |  1 |  1 |  1 |  5 |  2 |
| 电脑   |  1 |   1 |   |  5 |  2 |
| 显示器 |  1 |   1 |   |  5 |  2 |
| 游戏机 |  1 |   1 |   |  5 |  2 |

### 按需重置过滤器  

#### ALL  

去掉上下文过滤,反正整张表格或列中的所有值, 会忽略所以已经应用的过滤条件,这个功能在清除过滤或创建基于整张表的计算时非常有用  

##### 语法  

```DAX
ALL( [<table> | <column>[, <column>[, <column>[,…]]]] )  
```

!> 输入必须直接是表或者列,不能是产生表或列的表达式  

##### 返回值  

返回被清空过滤后的表或者列  

?> 通常用来作为中间过程功能,帮助其他计算公式来清楚过滤条件  

* ALL() 清空所有过滤条件

## 统计功能  

### 排序相关  

#### RANKX  

返回排序的值，可以根据通过表达式对一张表中的数据进行处理，为每一个排序对象产生一个表达式后的结果，通过对结果的排序，返回给每个需要排序的对象。  

希望得到销售人员的销售排名结果  

| 销售人员 | 销售额排名 |
| ------ | ------ |
| 销售A |  |
| 销售B |  |
| 销售C |  |
| 销售D |  |  

已有销售人员的销售额情况  

| 销售人员 | 销售额 |
| ------ | ------ |
| 销售A | 1000 |
| 销售B | 2000 |
| 销售C | 3000 |
| 销售D | 4000 |

可以通过RANKX得到  

| 销售人员 | 销售额排名 |
| ------ | ------ |
| 销售A | 4 |
| 销售B | 3 |
| 销售C | 2 |
| 销售D | 1 |  

##### 语法  

```DAX
RANKX(<table>, <expression>[, <value>[, <order>[, <ties>]]])  
```

##### 参数解析  

* table  
任何可以返回一张表的表达式  

* expression  
任何可以返回唯一值的表达式,比如例子中,你要得到销售D的排名,那么你的表达式得到的关于D的结果应该是唯一的一个数值,不然会报错  

* value  
(可选参数)是一个表达式,用于对上面表达式的结果,在进行处理,比如上面得到的结果是1,2,3,4而你想填成A,B,C,D,可以通过value转换,同理转关的结果针对一个分类应该是唯一的  

* order
(可选参数)排序方案,从高到低,还是从低到高  
0或者FALSE或者DESC: 降序,这是默认值,排名最高的返回1  
1或者TRUE或者ASC: 升序,排名最低的返回1  

* ties  
(可选参数)排名相同的情况下,下一个排名的处理方式  
Skip(默认值): 如果第5名有2个人,那么下一个人的排名是7  
Dense: 如果第五名有2个人,那么下一个人的排名是6  

?> 如果可选参数有的要有的不要,可以通过添加","隔出响应的位置并留空  

?> 如果返回值是空,那么如果表达式结果是数字,那么返回0,如果表示式是文本,那么返回空值  

##### 返回值  

返回排名值  

#### TOPN  

返回指定表的TOP N行

#### 语法

```DAX
TOPN(<n_value>, <table>, <orderBy_expression>, [<order>[, <orderBy_expression>, [<order>]]…])  
```

##### 参数解析 

* <n_value>  
想返回的行数,可以是表达式,但是表达式必须返回一个数量的值  

?> 实际返回行数可能大于要求的值,因排序相同的的行会返回,但是不占用行数名额,比如取top10,其中有两个是并列第5,那么会得到11行  
如果n_value为0或者小于0, 返回空  
返回的结果并不是排序后的结果  

* table  
任何可以返回一张表的表达式  

* orderBy_expression
可以让每一行得到一个值的表达式,这个值会被用来进行排序取值TOPN用  

* order
(可选参数)排序方法  
0或者FALSE或者DESC: 降序,这是默认值  
1或者TRUE或者ASC: 升序  

?> 可以有多个表达式和排序进行多条件排序  

